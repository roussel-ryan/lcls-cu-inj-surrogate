import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import torch
import gpytorch
import read_exp
import irregular_multitask
import transformer

def main():
    sim_x_df, sim_y_df = get_sim_data()
    exp_df = get_exp_data()

    #print(sim_df)
    #print(exp_df)

    param_names = sim_x_df.keys()

    sim_pts = 5000
    
    #access the input param columns based on param_names
    exp_x = torch.from_numpy(exp_df[param_names].to_numpy()).float()
    sim_x = torch.from_numpy(sim_x_df[param_names][-sim_pts:].to_numpy()).float()

    exp_y = torch.from_numpy(exp_df['stats_XRMS'].to_numpy()).float().flatten()
    sim_y = torch.from_numpy(sim_y_df['end_sigma_x'][-sim_pts:].to_numpy()).float().flatten()

    likelihood = gpytorch.likelihoods.GaussianLikelihood()

    sim_i = torch.full_like(sim_x, dtype = torch.long, fill_value = 0)
    exp_i = torch.full_like(exp_x, dtype = torch.long, fill_value = 1)

    full_x = torch.cat([sim_x, exp_x])
    full_i = torch.cat([sim_i, exp_i])
    full_y = torch.cat([sim_y, exp_y])

    tx = transformer.Transformer(full_x.numpy())
    ty = transformer.Transformer(full_y.numpy().reshape(-1,1), 'standardize')

    full_x = torch.from_numpy(tx.forward(full_x.numpy()))
    full_y = torch.from_numpy(ty.forward(full_y.numpy().reshape(-1,1))).flatten()
    

    
    
    model = irregular_multitask.MultitaskGPModel((full_x, full_i),
                                                 full_y,
                                                 likelihood,
                                                 ard_num_dims = 6)
    
    
    full_x = full_x.cuda()
    full_i = full_i.cuda()
    full_y = full_y.cuda()
    model = model.cuda()
    likelihood = likelihood.cuda()
    
    irregular_multitask.train_model(model, likelihood, full_x, full_y, full_i, iter_steps = 50)

    #print task cov matrix
    cov_fac = model.task_covar_module.covar_factor.data
    cov_var = torch.exp(model.task_covar_module.raw_var.data)
    kij = torch.matmul(cov_fac,torch.transpose(cov_fac,0,1)) + torch.diag(cov_var)
    print(kij)
    print(model.covar_module.lengthscale)

    
def get_sim_data():
    X_df = pd.read_pickle('frontend/X.p')
    Y_df = pd.read_pickle('frontend/Y.p')

    return X_df, Y_df
    
def get_exp_data():
    #import mapping between Impact and real parameters
    mapping = pd.read_csv('pv_mapping/cu_inj_impact.csv')
    mapping.index = mapping['device_pv_name']

    #import data frame from measurements
    measurements0 = read_exp.parse_solenoid_scan_data()

    #remove units to get scaling
    measurements = measurements0[[col_name for col_name in measurements0 if not '.EGU' in col_name]]

    #remove base solenoid strength
    measurements = measurements.drop(labels = ['SOLN:IN20:121:BDES'],axis=1)
    #print(measurements)

    scaled_measurements_raw = {}
    
    #transform measurement pv's into simulation pv's w/name and add to dataframe
    for col_name, col_values in measurements.items():
        if col_name == 'SOLN:IN20:121:BCTRL':
            col_name = 'SOLN:IN20:121:BDES'

        if not 'stats' in col_name: 
            #get scaling for col_name
            scale = mapping.loc[col_name]['impact_factor']
            impact_name = mapping.loc[col_name]['impact_name']

            #print(scale)
            #print(f'{col_name} : {impact_name} : {scale}')

            #scale each data column and rename the column for new dataframe
            if col_name == 'IRIS:LR20:130:MOTR_ANGLE':
                scaled_measurements_raw[impact_name] = convert_iris_diameter(np.asfarray(col_values))
            else:
                scaled_measurements_raw[impact_name] = scale * np.asfarray(col_values)

        else:
            scaled_measurements_raw[col_name] = 1e-6 * np.asfarray(col_values)
            

    #add laser pulse length
    scaled_measurements_raw['distgen:t_dist:length:value'] = 4.0
    scaled_measurements = pd.DataFrame(scaled_measurements_raw)
    #print(scaled_measurements)
    return scaled_measurements

def convert_iris_diameter(X):
    fit_data = np.loadtxt('pv_mapping/iris_diameter_mapping.md', skiprows = 4, max_rows = 10)

    #linear fit to data
    z = np.polyfit(*fit_data.T[::-1],1)
    p = np.poly1d(z)
    #plt.plot(*fit_data.T[::-1])

    return p(X) / 3.0


    
main()
plt.show()
